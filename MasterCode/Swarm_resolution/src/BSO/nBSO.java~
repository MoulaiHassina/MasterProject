package bso;

import environnement.Dataset;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

public class nBSO {

    //Dataset env;
    int size;
    Dataset env ;
    int MaxIter;
    int flip;
    int MaxChances;
    int nbtargets;
    int nbrBees;
    int localSize;

    int ObstacleColor =  new Color(255,0,0).getRGB();
    int EnvColor =  new Color(0,0,0).getRGB();

    /**************************************************************************************/
    public void SetParametersvector(ArrayList<Integer> parameters)
    {
        this.MaxIter= (int)( parameters.get ( 0 ));
        this.flip = (int) (parameters.get ( 1 ));
        this.MaxChances=(int) (parameters.get ( 2 ));
        this.nbrBees = (int) (parameters.get(3));
        this.localSize = parameters.get(4);
    }

    public int getNbtargets() {
        return nbtargets;
    }
    /**************************************************************************************/
    public ArrayList<Position> exe(Dataset envi,int nbrTarget) {


        int maxX=size,maxY=size,minX=0,minY=0;

        size=envi.size;
        env = envi;

        File f = null;
        BufferedImage image = null;
        try {
            f = new File("tt1.png"); //image file path
            image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
            image = ImageIO.read(f);

        }catch(IOException e){
            System.out.println("Error: "+e);
        }

        //drawing the env and obstacles
        for(int x=0;x<size;x++)
            for(int y=0;y<size;y++)
                if(env.getValue(x,y) == -1){
                    image.setRGB(y,x,ObstacleColor);
                }
                else{
                    image.setRGB(y,x,EnvColor);
                }



        /***other parameters**/
        int t = 0, nbrT = 0,Tcourant=-1;
        Bee S = new Bee();
        ArrayList<Position> Solution = new ArrayList();
        ArrayList<Bee> Bees = new ArrayList();
        ArrayList<Bee> TabooList = new ArrayList();
        ArrayList<Bee> Dance = new ArrayList();

        /***algorithm***/
        //init Sref randomly
        Bee Sref = new Bee(maxX, minX, maxY, minY);

        /*************************Search**************************/
        /*********************************************************/
        while (t < MaxIter && nbrT < nbrTarget) {// && Sref.fitness != 1) {
            if(nbrT != Tcourant){
                Tcourant = nbrT;
                S = new Bee();
            }

            //insert Sref in a taboo list;
            TabooList.add(Sref.copy());

            //determine SearchPoints from Sref
            Bees = globalSearch(env,Sref,flip,nbrBees);

            for (Bee b : Bees) {
                //local search
                Bee localBee = b.localSearch(env,localSize).copy();

                //store the result in Dance list
                Dance.add(localBee.copy());
            }

            //Assign the best solution to Sref
            Bee Sref1 = Sref.copy();
            Sref = selectBestSref(Sref, Dance, MaxChances,TabooList);
            //TODO: dinamic draw with obstacles avoidance
            image.getGraphics().drawLine(Sref1.Y(),Sref1.X(),Sref.Y(),Sref.X());



            System.out.println(t+" iteration");
            t++;


            if(Sref.fitness == 1 ){
                System.out.println("solution "+ (nbrT+1) +": "+Sref.toString());
                Sref.nbrChance=MaxChances;
                TabooList.add(Sref);
                Solution.add(Tcourant,Sref.position);
                nbrT++;
                //do{
                //    Sref = new Bee( size,  0,  size,  0);
                //}while(Sref.existIn(TabooList));
            }


        }



       this.nbtargets=nbrT;

        ColorTarget(env,image,Solution);
        //write image
        try{
            ImageIO.write(image, "png", f);
            System.out.println("Writing complete.");
        }catch(IOException e){
            System.out.println("Error: "+e);
        }

        return Solution;
    }


    /**************************************************************************************/
    /**************************************************************************************/
    /**************************************************************************************/


    public Bee selectBestSref(Bee Sref, ArrayList<Bee> Dance, int MaxChances,ArrayList<Bee> Taboo) {

        //select best bee solution in quality from Dance list
        Bee newB = getBestQuality(Dance,Taboo);
        Bee newSref = new Bee();

        //calculate Δf = f(Sbest(t+1)) – f(Sref(t));
        double deltaF = newB.fitness - Sref.fitness;

        if (deltaF >= 0) {

            //Sref = the best solution in quality;
            newSref = newB.copy();
            newSref.nbrChance = 0;

        } else {

            Sref.nbrChance = Sref.nbrChance + 1;
            if (Sref.nbrChance >= MaxChances) {

                //newSref = the best solution in diversity;
                newSref = getBestDiversity(Dance,Taboo);
                newSref.nbrChance = 0;
            }else{
                newSref = Sref.copy();
            }

        }

        return newSref;
    }

    public Bee getBestQuality(ArrayList<Bee> Dance,ArrayList<Bee> Taboo){
        Bee bee = new Bee();
        boolean allInTaboo = true;

        for(int i = 0 ; i<Dance.size() ; i++){

            if(Dance.get(i).existIn(Taboo) == false){
                bee = Dance.get(i);
                //if in dance and not in taboo list
                allInTaboo = false;
                if(bee.fitness < Dance.get(i).fitness){
                    bee = Dance.get(i).copy();
                }
            }
        }

        if(allInTaboo == true){

            do{
                bee = new Bee( size,  0,  size,  0);
            }while(bee.existIn(Taboo));
            bee.evaluate(env);
        }
        return bee;
    }

    public Bee getBestDiversity(ArrayList<Bee> Dance2,ArrayList<Bee> Taboo){
        Bee bee = new Bee();
        double d,minDistance ;
        boolean allInTaboo = true;
        ArrayList<Bee> Dance = new ArrayList();


        for(int i = 0 ; i<Dance2.size() ; i++) {
            if (Dance2.get(i).existIn(Taboo) == false) {
                allInTaboo = false;
                Dance.add(Dance2.get(i).copy());
            }
        }

        if(allInTaboo == true){

            do{
                bee = new Bee( size,  0,  size,  0);
            }while(bee.existIn(Taboo));

            bee.evaluate(env);
        }
        else {
            for (int i = 0; i < Dance.size() - 1; i++) {

                minDistance = Dance.get(i).distance(Dance.get(i + 1));
                for (int j = i + 1; j < Dance.size(); j++) {
                    d = Dance.get(i).distance(Dance.get(j));
                    if (d < minDistance && d != 0) {
                        minDistance = d;
                    }
                }
                Dance.get(i).minDistance = minDistance;
            }

            for (int i = 0; i < Dance.size(); i++) {
                if (bee.minDistance < Dance.get(i).minDistance) {
                    bee = Dance.get(i).copy();
                }
            }
        }

        return bee;
    }

    /********************************************************************************/

    public ArrayList<Bee> globalSearch(Dataset env,Bee Sref, int flip, int nbrBees){
        ArrayList<Bee> Bees = new ArrayList();

        int rand;

        //generate solutions
        ArrayList<Position> circlePos = Sref.position.getCiclePositions(env,flip,localSize);
        if(nbrBees > circlePos.size()) nbrBees=circlePos.size();


        for (int i = 0; i < nbrBees; i++) {
            //creat a bee
            Bee bee = new Bee();

            //put the solution in the bee
            Random random = new Random();
            rand = random.nextInt(circlePos.size() );
            bee.putSolution(circlePos.get(rand));
            circlePos.remove(rand);

            //evaluate solution
            bee.evaluate(env);

            //insert it in Bees list
            Bees.add(bee);
        }

        return Bees;
    }


    /*************************************************/
    public static void ColorTarget(Dataset env,BufferedImage image, ArrayList<Position> Solution){
        Color c2 = new Color(20, 20, 250);


        for(int c=0; c<Solution.size();c++) {
            image.setRGB(Solution.get(c).Y, Solution.get(c).X,c2.getRGB());

            if (env.valide(Solution.get(c).Y+1, Solution.get(c).X+1))
                image.setRGB(Solution.get(c).Y+1, Solution.get(c).X+1, c2.getRGB());
            if (env.valide(Solution.get(c).Y-1, Solution.get(c).X-1))
                image.setRGB(Solution.get(c).Y-1, Solution.get(c).X-1, c2.getRGB());
            if (env.valide(Solution.get(c).Y+1, Solution.get(c).X-1))
                image.setRGB(Solution.get(c).Y+1, Solution.get(c).X-1, c2.getRGB());
            if (env.valide(Solution.get(c).Y-1, Solution.get(c).X+1))
                image.setRGB(Solution.get(c).Y-1, Solution.get(c).X+1, c2.getRGB());
            if (env.valide(Solution.get(c).Y, Solution.get(c).X+1))
                image.setRGB(Solution.get(c).Y, Solution.get(c).X + 1, c2.getRGB());
            if (env.valide(Solution.get(c).Y, Solution.get(c).X - 1))
                image.setRGB(Solution.get(c).Y, Solution.get(c).X - 1, c2.getRGB());
            if (env.valide(Solution.get(c).Y-1, Solution.get(c).X))
                image.setRGB(Solution.get(c).Y-1, Solution.get(c).X, c2.getRGB());
            if (env.valide(Solution.get(c).Y+1, Solution.get(c).X))
                image.setRGB(Solution.get(c).Y+1, Solution.get(c).X, c2.getRGB());
        }
    }




}
